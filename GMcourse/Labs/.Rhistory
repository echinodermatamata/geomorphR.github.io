## plots
pleth.raw <- gm.prcomp(Y.gpa$coords)
gps <- as.factor(paste(plethodon$species, plethodon$site))
par(mar=c(2, 2, 2, 2))
plot(pleth.raw, pch=22, cex = 1.5, bg = gps)
#  Add things as desired using standard R plotting
text(par()$usr[1], 0.1*par()$usr[3], labels = "PC1 - 45.64%", pos = 4, font = 2)
text(0, 0.95*par()$usr[4], labels = "PC2 - 18.80%", pos = 4, font = 2)
legend("topleft", pch=22, pt.bg = unique(gps), legend = levels(gps))
M <- mshape(Y.gpa$coords)
pleth.anova <- procD.lm(coords ~ species*site, data=gdf, print.progress = FALSE)
X <- pleth.anova$X
X[1:10,] # includes intercept; remove for better functioning
X <- X[,-1]
symJord <- c(0,1,0) # design for P. Jordani in sympatry
alloJord <- c(0,0,0) # design for P. Jordani in allopatry
preds <- shape.predictor(pleth.anova$GM$fitted, x = X, Intercept = TRUE,
symJord=symJord, alloJord=alloJord)
plotRefToTarget(M, preds$symJord, links = plethodon$links, mag=2)
plotRefToTarget(M, preds$alloJord, links = plethodon$links, mag=2)
# via picknplot
par(mar = c(5, 5, 2, 2))
pleth.anova.plot <- plot(pleth.anova, type = "PC", pch = 21,
bg = interaction(gdf$species, gdf$site))
picknplot.shape(pleth.anova.plot)
## Nested Models (i.e., error term adjustment)
data("larvalMorph")
Y.gpa <- gpagen(larvalMorph$tailcoords, curves = larvalMorph$tail.sliders,
ProcD = TRUE, print.progress = FALSE)
gdf <- geomorph.data.frame(Y.gpa, treatment = larvalMorph$treatment,
family = larvalMorph$family)
fit <- procD.lm(coords ~ treatment/family, data = gdf,
print.progress = FALSE, iter = 199)
anova(fit) # treatment effect not adjusted
anova(fit, error = c("treatment:family", "Residuals")) # treatment effect updated (adjusted)
plot(Y.gpa$coords)
## Nested Models (i.e., error term adjustment)
data("larvalMorph")
plotAllSpecimens(Y.gpa$coords)
anova(fit) # treatment effect not adjusted
anova(fit, error = c("treatment:family", "Residuals")) # treatment effect updated (adjusted)
## Estimated via Linear Models
data(Pupfish)
fit <- lm.rrpp(coords ~ Pop * Sex, data = Pupfish, iter = 999, print.progress = FALSE)
reveal.model.designs(fit)
anova(fit)
TA <- trajectory.analysis(fit, groups = Pupfish$Pop, traj.pts = Pupfish$Sex)
summary(TA, attribute = "MD") # Magnitude difference (absolute difference between path distances)
summary(TA, attribute = "TC", angle.type = "deg") # Correlations (angles) between trajectories
summary(TA, attribute = "SD") # No shape differences between vectors
# Retain results
TA.summary <- summary(TA, attribute = "MD")
TA.summary$summary.table
# Alternate summary style
summary(TA, attribute = "MD", stat.table = FALSE)
# Plot results
TP <- plot(TA, pch = as.numeric(Pupfish$Pop) + 20, bg = as.numeric(Pupfish$Sex),
cex = 0.7, col = "gray")
add.trajectories(TP, traj.pch = c(21, 22), start.bg = 1, end.bg = 2)
legend("topright", levels(Pupfish$Pop), pch =  c(21, 22), pt.bg = 1)
procD.lm
## Estimated via Linear Models
data(pupfish)
fit <- procD.lm(coords ~ Pop * Sex, data = pupfish, iter = 999, print.progress = FALSE)
reveal.model.designs(fit)
anova(fit)
TA <- trajectory.analysis(fit, groups = pupfish$Pop, traj.pts = pupfish$Sex)
summary(TA, attribute = "MD") # Magnitude difference (absolute difference between path distances)
summary(TA, attribute = "TC", angle.type = "deg") # Correlations (angles) between trajectories
summary(TA, attribute = "SD") # No shape differences between vectors
# Retain results
TA.summary <- summary(TA, attribute = "MD")
TA.summary$summary.table
# Alternate summary style
summary(TA, attribute = "MD", stat.table = FALSE)
# Plot results
TP <- plot(TA, pch = as.numeric(Pupfish$Pop) + 20, bg = as.numeric(Pupfish$Sex),
cex = 0.7, col = "gray")
add.trajectories(TP, traj.pch = c(21, 22), start.bg = 1, end.bg = 2)
legend("topright", levels(Pupfish$Pop), pch =  c(21, 22), pt.bg = 1)
# data input
library(geiger)
plethtree <- read.tree('Data/plethtree.tre')
plot(plethtree)
dat <- read.csv('Data/svl.csv', header=TRUE, row.names=1)
svl <-dat[,1]; names(svl) <- rownames(dat)
shape <- readland.tps('Data/headshape.tps',specID = "ID",warnmsg = FALSE)
match.data <- treedata(plethtree,svl)
plethgps <- read.csv('Data/Gps.csv',header=TRUE, row.names=1)
plethgps <- plethgps[match(dimnames(shape)[[3]],rownames(plethgps)),]
elev <- as.factor(plethgps$ElevGp); names(elev) <- rownames(plethgps)
gdf <- geomorph.data.frame(shape=shape, svl=svl,elev = elev, plethtree=plethtree)
links <- matrix(c(4,3,2,1,1,6,7,8,9,10,1,1,11,5,5,4,2,3,7,8,9,10,11,9,10,1),
ncol=2,byrow=FALSE)
plot(ladderize(plethtree),edge.width=3)
axisPhylo(1)
# PGLS regression
pgls.reg <- procD.pgls(f1 = shape~svl, effect.type = 'cohen', data=gdf,
phy=plethtree, print.progress = FALSE)
summary(pgls.reg)
allom.plot <- plot(pgls.reg, type = "regression", predictor = gdf$svl,
reg.type ="RegScore", pch=19, cex=1.5) # make sure to have a predictor
#plots
preds <- shape.predictor(pgls.reg$GM$pgls.fitted, x= allom.plot$RegScore, Intercept = FALSE,
predmin = min(allom.plot$RegScore),
predmax = max(allom.plot$RegScore))
M <- mshape(shape)
plotRefToTarget(M, preds$predmin, mag=3, links = links)
plotRefToTarget(M, preds$predmax, mag=3, links = links)
# PGLS ANOVA
pgls.aov <- procD.pgls(f1 = shape~elev, effect.type = 'cohen', data=gdf,
phy=plethtree, print.progress = FALSE)
summary(pgls.aov)
pc.plot <- plot(pgls.aov,type = "PC", pch=21, cex=1.5,bg=gdf$elev)
shapeHulls(pc.plot, groups = gdf$elev,
group.cols = c("red", "black"),
group.lwd = rep(1, 2), group.lty = c(2, 1))
legend("topright", levels(gdf$elev),
col = c("black", "red"),
lwd = rep(1,2), lty = c(2, 1))
# plots
Low <- c(1) # design for low elevation
High <- c(0) # design for high elevation
preds <- shape.predictor(arrayspecs(pgls.aov$pgls.fitted, 11,2), x= pgls.aov$X[,-1],
Intercept = TRUE, Low = Low, High = High)
par(mfrow=c(1,2))
plotRefToTarget(M, preds$Low, mag=2, links=links)
mtext("Low Elevation")
plotRefToTarget(M, preds$High, mag=2, links=links)
mtext("High Elevation")
par(mfrow=c(1,1))
# via picknplot.shape
picknplot.shape(pc.plot)
plethtree <- read.tree('Data/plethtree.tre')
plot(plethtree)
dat <- read.csv('Data/svl.csv', header=TRUE, row.names=1)
svl <-dat[,1]; names(svl) <- rownames(dat)
shape <- readland.tps('Data/headshape.tps',specID = "ID",warnmsg = FALSE)
dim(dat)
length(plethtree$tip.label)
dat <- read.csv('Data/svl.csv', header=TRUE, row.names=1)
svl <-dat[,1]; names(svl) <- rownames(dat)
shape <- readland.tps('Data/headshape.tps',specID = "ID",warnmsg = FALSE)
match.data <- treedata(plethtree,svl)
plethgps <- read.csv('Data/Gps.csv',header=TRUE, row.names=1)
plethgps <- plethgps[match(dimnames(shape)[[3]],rownames(plethgps)),]
elev <- as.factor(plethgps$ElevGp); names(elev) <- rownames(plethgps)
gdf <- geomorph.data.frame(shape=shape, svl=svl,elev = elev, plethtree=plethtree)
links <- matrix(c(4,3,2,1,1,6,7,8,9,10,1,1,11,5,5,4,2,3,7,8,9,10,11,9,10,1),
ncol=2,byrow=FALSE)
plot(ladderize(plethtree),edge.width=3)
axisPhylo(1)
?procD.plgs
?procD.pgls
# PGLS regression
pgls.reg <- procD.pgls(f1 = shape~svl, effect.type = 'cohen', data=gdf,
phy=plethtree, print.progress = FALSE)
summary(pgls.reg)
allom.plot <- plot(pgls.reg, type = "regression", predictor = gdf$svl,
reg.type ="RegScore", pch=19, cex=1.5) # make sure to have a predictor
#plots
preds <- shape.predictor(pgls.reg$GM$pgls.fitted, x= allom.plot$RegScore, Intercept = FALSE,
predmin = min(allom.plot$RegScore),
predmax = max(allom.plot$RegScore))
M <- mshape(shape)
plotRefToTarget(M, preds$predmin, mag=3, links = links)
plotRefToTarget(M, preds$predmax, mag=3, links = links)
# Phylogenetic Ordination
plot.res <- gm.prcomp(shape,phy=plethtree, data=gdf)
ord.plot <- plot(plot.res,phylo = TRUE, pch=21, bg="red", cex=1.5)
allom.plot <- plot(pgls.reg, type = "regression", predictor = gdf$svl,
reg.type ="RegScore", pch=19, cex=1.5) # make sure to have a predictor
fit.line <- lm(allom.plot$RegScore~gdf$svl)
abline(fit.line,col = "red")
# PGLS ANOVA
pgls.aov <- procD.pgls(f1 = shape~elev, effect.type = 'cohen', data=gdf,
phy=plethtree, print.progress = FALSE)
summary(pgls.aov)
pc.plot <- plot(pgls.aov,type = "PC", pch=21, cex=1.5,bg=gdf$elev)
shapeHulls(pc.plot, groups = gdf$elev,
group.cols = c("red", "black"),
group.lwd = rep(1, 2), group.lty = c(2, 1))
legend("topright", levels(gdf$elev),
col = c("black", "red"),
lwd = rep(1,2), lty = c(2, 1))
# Phylogenetic PLS
land.gps<-c("A","A","A","A","A","B","B","B","B","B","B")
PLS.Y <- phylo.integration(A = gdf$shape, partition.gp = land.gps,
phy= plethtree, print.progress = FALSE)
summary(PLS.Y)
pls.plot <- plot(PLS.Y)
picknplot.shape(pls.plot, mag = 2)
# Phylogenetic Ordination
plot.res <- gm.prcomp(shape,phy=plethtree, data=gdf)
ord.plot <- plot(plot.res,phylo = TRUE, pch=21, bg="red", cex=1.5)
ord.plot <- plot(plot.res,phylo = FALSE, pch=21, bg=gdf$elev, cex=1.5)
plot.res <- gm.prcomp(shape,phy=plethtree, data=gdf)
ord.plot <- plot(plot.res,phylo = FALSE, pch=21, bg=gdf$elev, cex=1.5)
shapeHulls(pc.plot, groups = gdf$elev,
group.cols = c("red", "black"),
group.lwd = rep(1, 2), group.lty = c(2, 1))
shapeHulls(ord.plot, groups = gdf$elev,
group.cols = c("red", "black"),
group.lwd = rep(1, 2), group.lty = c(2, 1))
legend("topright", levels(gdf$elev),
col = c("black", "red"),
lwd = rep(1,2), lty = c(2, 1))
# Phylogenetic Ordination
plot.res <- gm.prcomp(shape,phy=plethtree, data=gdf)
ord.plot <- plot(plot.res,phylo = TRUE, pch=21, bg="red", cex=1.5)
picknplot.shape(ord.plot, mag = 2)
# Phylogenetic Signal
PS.shape <- physignal(gdf$shape, gdf$plethtree, print.progress = FALSE)
summary(PS.shape)
plot(PS.shape)
# Comparing Net Rates of Evolution
ER<-compare.evol.rates(A=gdf$shape, phy=plethtree,gp=gdf$elev,iter=999,
method = 'permutation', print.progress = FALSE)
summary(ER)
plot(ER)  # COMPARISONS AMONG CLADES
ER$sigma.d.all
EMR <- compare.multi.evol.rates(A=gdf$shape, phy=plethtree, gp=land.gps, print.progress = FALSE)
summary(EMR)
plot(EMR)  # COMPARISONS AMONG TRAITS
# Simple Allometry
data(plethodon)
Y.gpa <- gpagen(plethodon$land, print.progress = FALSE)    #GPA-alignment
gdf <- geomorph.data.frame(Y.gpa, site = plethodon$site,
species = plethodon$species)
fit <- procD.lm(coords ~ log(Csize), data=gdf, iter=999, print.progress = FALSE)
anova(fit)
# Predline
plotAllometry(fit, size = gdf$Csize, logsz = TRUE, method = "PredLine", pch = 19)
# RegScore
plotAllometry(fit, size = gdf$Csize, logsz = TRUE, method = "RegScore", pch = 19)
# CAC
plotAllometry(fit, size = gdf$Csize, logsz = TRUE, method = "CAC", pch = 19)
fit.unique <- procD.lm(coords ~ Csize * species * site, data=gdf, iter=999, print.progress = FALSE)
fit.common <- procD.lm(coords ~ Csize + species * site, data=gdf, iter=999, print.progress = FALSE)
anova(fit.common, fit.unique)
# Pairwise comparisons
slope.pw <- pairwise(fit.unique, fit.null = fit.common,
groups = interaction(gdf$species, gdf$site),
covariate = gdf$Csize)
summary(slope.pw, test.type = "VC", angle.type = "deg") # angular differences
summary(slope.pw, test.type = "dist", angle.type = "deg") # amount of shape change differences
# Predline
plotAllometry(fit.unique, size = gdf$Csize, logsz = TRUE, method = "PredLine",
pch = 19, col = as.numeric(interaction(gdf$species, gdf$site)))
# RegScore
plotAllometry(fit.unique, size = gdf$Csize, logsz = TRUE, method = "RegScore",
pch = 19, col = as.numeric(interaction(gdf$species, gdf$site)))
# Size-Shape Space
pc.plot <- plotAllometry(fit.unique, size = gdf$Csize, logsz = TRUE, method = "size.shape",
pch = 19, col = as.numeric(interaction(gdf$species, gdf$site)))
summary(pc.plot$size.shape.PCA)
fit.unique <- procD.lm(coords ~ Csize * species * site, data=gdf, iter=999, print.progress = FALSE)
fit.common <- procD.lm(coords ~ Csize + species * site, data=gdf, iter=999, print.progress = FALSE)
anova(fit.common, fit.unique)
fit.unique <- procD.lm(coords ~ Csize * species * site, data=gdf, iter=999, print.progress = FALSE)
fit.common <- procD.lm(coords ~ Csize + species * site, data=gdf, iter=999, print.progress = FALSE)
anova(fit.common, fit.unique)
# Pairwise comparisons
slope.pw <- pairwise(fit.unique, fit.null = fit.common,
groups = interaction(gdf$species, gdf$site),
covariate = gdf$Csize)
summary(slope.pw, test.type = "VC", angle.type = "deg") # angular differences
summary(slope.pw, test.type = "dist", angle.type = "deg") # amount of shape change differences
# Predline
plotAllometry(fit.unique, size = gdf$Csize, logsz = TRUE, method = "PredLine",
pch = 19, col = as.numeric(interaction(gdf$species, gdf$site)))
# RegScore
plotAllometry(fit.unique, size = gdf$Csize, logsz = TRUE, method = "RegScore",
pch = 19, col = as.numeric(interaction(gdf$species, gdf$site)))
# Size-Shape Space
pc.plot <- plotAllometry(fit.unique, size = gdf$Csize, logsz = TRUE, method = "size.shape",
pch = 19, col = as.numeric(interaction(gdf$species, gdf$site)))
summary(pc.plot$size.shape.PCA)
anova(fit.unique)
anova(fit.common, fit.unique)
?geomorph:::estimate.missing
library(geomorph)
data(plethodon)
matrix(Y.gpa$coords[,,3])
data(plethodon)
Y.gpa <- gpagen(plethodon$land, print.progress = FALSE)
plethland<-Y.gpa$coords
plethland[3,,2]<-plethland[8,,2]<-NA  #create missing landmarks
plethland[3,,5]<-plethland[8,,5]<-plethland[9,,5]<-NA
plethland[3,,10]<-NA
new.tps <- estimate.missing(plethland,method="TPS")
new.reg <- estimate.missing(plethland,method="Reg")
vector(Y.gpa$coords[,,3])
as.vector(Y.gpa$coords[,,3])
crossprod(as.vector(Y.gpa$coords[,,3]),as.vector(new.tps[,,3])
)
dist(as.vector(Y.gpa$coords[,,3]),as.vector(new.tps[,,3]))
dist(rbind(as.vector(Y.gpa$coords[,,3]),as.vector(new.tps[,,3])))
dist(rbind(as.vector(Y.gpa$coords[,,3]),as.vector(new.reg[,,3])))
setwd("C:/DeanData/Teaching/Workshops/GeomorphWorkshops/GMcourse/Labs")
library(StereoMorph)
library(geomorph)
# Landmark digtizing: see Tutorial for additional instructions
digitizeImages(image.file='Data/Images', shapes.file='Data/Shapes',
landmarks.ref=paste("LM", c(1:5), sep=""))
# Landmark digtizing: see Tutorial for additional instructions
digitizeImages(image.file='Data/Fish-Images', shapes.file='Data/Fish-Shapes',
landmarks.ref=paste("LM", c(1:5), sep=""))
#### build some missing data (EXAMPLE ONLY)
data(plethodon)
plethland<-plethodon$land
plethland[3,,2]<-plethland[8,,2]<-NA  #create missing landmarks
plethland[3,,5]<-plethland[8,,5]<-plethland[9,,5]<-NA
plethland[3,,10]<-NA
# Estimate via TPS or Regression
estimate.missing(plethland,method="TPS")
estimate.missing(plethland,method="Reg")
## 3B: Check for Outliers (EXAMPLE ONLY)
newland <- plethodon$land
newland[c(1,8),,2] <- newland[c(8,1),,2] #digitized out of order
newland[c(3,11),,26] <- newland[c(11,3),,2]
Y <- gpagen(newland, print.progress = FALSE)
plotOutliers(Y$coords, inspect.outliers = T)
plotOutliers(Y$coords, inspect.outliers = F)
plotOutliers(Y$coords, inspect.outliers = T)
# Estimate via TPS or Regression
new.tps <- estimate.missing(plethland,method="TPS")
new.reg <- estimate.missing(plethland,method="Reg")
plotRefToTarget(Y.gpa$coords[,,3],new.tps[,,3],links=plethodon$links)
#### build some missing data (EXAMPLE ONLY)
data(plethodon)
Y.gpa <- gpagen(plethodon$land, print.progress = FALSE)
plethland<-Y.gpa$coords
plethland[3,,2]<-plethland[8,,2]<-NA  #create missing landmarks
plethland[3,,5]<-plethland[8,,5]<-plethland[9,,5]<-NA
plethland[3,,10]<-NA
# Estimate via TPS or Regression
new.tps <- estimate.missing(plethland,method="TPS")
new.reg <- estimate.missing(plethland,method="Reg")
plotRefToTarget(Y.gpa$coords[,,3],new.tps[,,3],links=plethodon$links)
plotRefToTarget(Y.gpa$coords[,,3],new.reg[,,3],links=plethodon$links)
plotRefToTarget(Y.gpa$coords[,,3],new.tps[,,3],links=plethodon$links, mag=3)
plotRefToTarget(Y.gpa$coords[,,3],new.reg[,,3],links=plethodon$links, mag=3)
plotRefToTarget(Y.gpa$coords[,,3],new.tps[,,3],links=plethodon$links, mag=3)
plotRefToTarget(Y.gpa$coords[,,3],new.reg[,,3],links=plethodon$links, mag=3)
## 3B: Check for Outliers (EXAMPLE ONLY)
newland <- plethodon$land
newland[c(1,8),,2] <- newland[c(8,1),,2] #digitized out of order
newland[c(3,11),,26] <- newland[c(11,3),,2]
Y <- gpagen(newland, print.progress = FALSE)
plotOutliers(Y$coords, inspect.outliers = F)
plotOutliers(Y$coords, inspect.outliers = T)
data(plethodon)
pleth.gpa <- gpagen(plethodon$land, print.progress = F)
summary(pleth.gpa)
plot(pleth.gpa)
plotAllSpecimens(pleth.gpa$coords, links = plethodon$links)
library(geomorph)
library(StereoMorph)
shapes <- readShapes("Data/example.digitized")
shapesGM <- readland.shapes(shapes,
nCurvePts = c(12, 12, 12, 8, 6, 6, 6, 12, 10))
Y.gpa <- gpagen(shapesGM)
summary(Y.gpa)
head(Y.gpa)
head(summary(Y.gpa))
plot(Y.gpa)
library(geomorph)
data(plethodon)
Y.gpa <- gpagen(plethodon$land, print.progress = F)    # GPA-alignment
par(mfrow=c(1,2))
plotAllSpecimens(plethodon$land, links=plethodon$links)  # Raw data
mtext("Raw Data")
plotAllSpecimens(Y.gpa$coords, links=plethodon$links)    # GPA-aligned data
mtext("GPA-Aligned Specimens")
par(mfrow=c(1,1))
?gm.prcomp
gps <- as.factor(paste(plethodon$species, plethodon$site))  #define some groups for plotting
PCA <- gm.prcomp(Y.gpa$coords)
summary(PCA)
plot(PCA)
par(mar=c(2, 2, 2, 2))
plot(PCA, pch=22, cex = 1.5, bg = gps)
#  Add things as desired using standard R plotting
text(par()$usr[1], 0.1*par()$usr[3], labels = "PC1 - 36.74%", pos = 4, font = 2)
text(0, 0.95*par()$usr[4], labels = "PC2 - 31.02%", pos = 4, font = 2)
legend("topleft", pch=22, pt.bg = unique(gps), legend = levels(gps))
library(geomorph)
data(plethodon)
Y.gpa <- gpagen(plethodon$land, print.progress = F)
PCA <- gm.prcomp(Y.gpa$coords)
summary(PCA)
plot(PCA)
gps <- as.factor(paste(plethodon$species, plethodon$site))  #define some groups for plotting
plot(PCA, pch=22, cex = 1.5, bg = gps)
legend("topleft", pch=22, pt.bg = unique(gps), legend = levels(gps))
M <- mshape(Y.gpa$coords)
plotRefToTarget(M,Y.gpa$coords[,,39], links=plethodon$links)
mtext("TPS")
plotRefToTarget(M,Y.gpa$coords[,,39], mag=2.5, links=plethodon$links)
mtext("TPS: 2.5X magnification")
par(mfrow=c(1,1))
par(mfrow=c(3,2))
plotRefToTarget(M,Y.gpa$coords[,,39], links=plethodon$links)
mtext("TPS")
plotRefToTarget(M,Y.gpa$coords[,,39], mag=2.5, links=plethodon$links)
mtext("TPS: 2.5X magnification")
plotRefToTarget(M,Y.gpa$coords[,,39], links=plethodon$links, method="vector", mag=3)
mtext("Vector Displacements")
plotRefToTarget(M,Y.gpa$coords[,,39], links=plethodon$links,gridPars=gridPar(pt.bg="red", link.col="green", pt.size = 1), method="vector", mag=3)
mtext("Vector Displacements: Other Options")
par(mfrow=c(1,1))
par(mfrow=c(3,2))
plotRefToTarget(M,Y.gpa$coords[,,39], links=plethodon$links)
mtext("TPS")
plotRefToTarget(M,Y.gpa$coords[,,39], mag=2.5, links=plethodon$links)
mtext("TPS: 2.5X magnification")
plotRefToTarget(M,Y.gpa$coords[,,39], links=plethodon$links, method="vector", mag=3)
mtext("Vector Displacements")
plotRefToTarget(M,Y.gpa$coords[,,39], links=plethodon$links,gridPars=gridPar(pt.bg="red", link.col="green", pt.size = 1), method="vector", mag=3)
mtext("Vector Displacements: Other Options")
plotRefToTarget(M,Y.gpa$coords[,,39], mag=2, outline=plethodon$outline)
mtext("Outline Deformation")
plotRefToTarget(M,Y.gpa$coords[,,39], method="points", outline=plethodon$outline)
mtext("Outline Deformations Ref (gray) & and Tar (black)")
par(mfrow=c(1,1))
PC <- PCA$pc.scores[,1]
preds <- shape.predictor(Y.gpa$coords, x= PC, Intercept = FALSE,
pred1 = min(PC), pred2 = max(PC)) # PC 1 extremes, more technically
?shape.predictor
PC <- PCA$x[,1]
preds <- shape.predictor(Y.gpa$coords, x= PC, Intercept = FALSE,
pred1 = min(PC), pred2 = max(PC)) # PC 1 extremes, more technically
plotRefToTarget(M, preds$pred1, links = plethodon$links)
mtext("PC1 - Min.")
plotRefToTarget(M, preds$pred2, links = plethodon$links)
mtext("PC1 - Max.")
# PCA-based
PC <- PCA$x[,1]
preds <- shape.predictor(Y.gpa$coords, x= PC, Intercept = FALSE,
pred1 = min(PC), pred2 = max(PC)) # PC 1 extremes, more technically
par(mfrow=c(1,2))
plotRefToTarget(M, preds$pred1, links = plethodon$links)
mtext("PC1 - Min.")
plotRefToTarget(M, preds$pred2, links = plethodon$links)
mtext("PC1 - Max.")
par(mfrow=c(1,1))
pleth.pca.plot <- plot(PCA)
picknplot.shape(pleth.pca.plot)
# Regression-based
gdf <- geomorph.data.frame(Y.gpa)
plethAllometry <- procD.lm(coords ~ log(Csize), data=gdf, print.progress = FALSE)
allom.plot <- plot(plethAllometry,
type = "regression",
predictor = log(gdf$Csize),
reg.type ="PredLine") # make sure to have a predictor
preds <- shape.predictor(plethAllometry$GM$fitted, x= allom.plot$RegScore, Intercept = FALSE,
predmin = min(allom.plot$RegScore),
predmax = max(allom.plot$RegScore))
par(mfrow=c(1,2))
plotRefToTarget(M, preds$predmin, mag=3, links = plethodon$links)
mtext("Regression Min")
plotRefToTarget(M, preds$predmax, mag=3, links = plethodon$links)
mtext("Regression Max")
par(mfrow=c(1,1))
picknplot.shape(allom.plot)
# Group Differences
gdf <- geomorph.data.frame(Y.gpa, species = plethodon$species, site = plethodon$site)
pleth.anova <- procD.lm(coords ~ species*site, data=gdf, print.progress = FALSE)
X <- pleth.anova$X
X # includes intercept; remove for better functioning
X <- X[,-1]
symJord <- c(0,1,0) # design for P. Jordani in sympatry
alloJord <- c(0,0,0) # design for P. Jordani in allopatry
preds <- shape.predictor(arrayspecs(pleth.anova$fitted, 12, 2), x = X, Intercept = TRUE,
symJord=symJord, alloJord=alloJord)
par(mfrow=c(1,2))
plotRefToTarget(M, preds$symJord, links = plethodon$links, mag=2)
mtext("Sympatric P. Jordani")
plotRefToTarget(M, preds$alloJord, links = plethodon$links, mag=2)
mtext("Allopatric P. Jordani")
par(mfrow=c(1,1))
plot.anova <- plot(pleth.anova, type = "PC", pch = 21,
bg = interaction(gdf$species, gdf$site),
asp = 1)
picknplot.shape(plot.anova)
##### 2C: 3D Warping
scallops <- readland.tps("Data/scallops for viz.tps", specID = "ID")
##### 2C: 3D Warping
scallops <- readland.tps("Data/scallops for viz.tps", specID = "ID")
ref <- mshape(scallops)
refmesh <- warpRefMesh(read.ply("Data/glyp02L.ply"),
scallops[,,1], ref, color=NULL, centered=T)
refmesh <- warpRefMesh(read.ply("Data/glyp02L.ply"),
scallops[,,1], ref, color=NULL, centered=T)
plotTangentSpace(scallops, axis1 = 1, axis2 = 2, warpgrids=T, mesh= refmesh)
?warpRefMesh
plotAllSpecimens(scallops)
PCA.scallop <- gm.prcomp(scallops)
plot(PCA.scallop)
?gm.prcomp
PCA.scallop <- gm.prcomp(scallops)
PC.sc <- PCA.scallop$x[,1]
sc.preds <- shape.predictor(scallops, x= PC.sc, Intercept = FALSE,
pred1 = min(PC.sc), pred2 = max(PC.sc)) # PC 1 extremes, more technically
plotRefToTarget(ref, preds$pred1, links = links)
plotRefToTarget(ref, preds$pred1)
ref
plotRefToTarget(ref, sc.preds$pred1)
plotRefToTarget(ref, sc.preds$pred2)
plotRefToTarget(ref, sc.preds$pred1, mesh = refmesh, method = "surface", mag = 1)
plotRefToTarget(ref, sc.preds$pred2, mesh = refmesh, method = "surface", mag = 1)
